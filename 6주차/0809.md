### 안정 정렬/불안정 정렬

### 안정 정렬 (Stable Sort)

안정정렬은 중복된 값을 입력 순서와 동일하게 정렬하는 정렬 알고리즘의 특성을 말합니다.

대표적으로 [삽입정렬](https://hongl.tistory.com/4?category=922601), [병합정렬](https://hongl.tistory.com/8?category=922601), [버블정렬](https://hongl.tistory.com/3?category=922601) 이 있습니다. 각 알고리즘을 살펴보시면 중복된 부분은 순서가 유지되는 것을 알 수 있습니다.

### 불안정 정렬 (Unstable Sort)

불안정 정렬은 안정 정렬과 반대로 중복된 값이 입력 순서와 동일하지 않게 정렬되는 알고리즘을 말합니다.

대표적으로 [퀵정렬](https://hongl.tistory.com/5?category=922601), [선택정렬](https://hongl.tistory.com/2?category=922601), [계수정렬](https://hongl.tistory.com/6?category=922601) 이 있습니다.

### counting 정렬

어떨 때 사용?

데이터의 숫자 범주가 좁은 범위에 있을 때 유리

숫자의 개수를 세서 리스트에 넣는 것

리스트의 길이는 어떻게 결정?

- 원래 데이터에서의 max 값

```jsx
# 카운팅 정렬 코드
nums = [4, 4, 2, 3, 5, 5, 1, 1, 5]

count = [0] * (max(nums) + 1)  # 갯수 세는 리스트
sorted_nums = [0] * len(nums)  # 정렬된 리스트의 원형 틀

for num in nums:  # 일단 몇개씩 있는지 카운트
    count[num] += 1

# 그냥 숫자에 따른 개수 리스트까지만 있으면 정렬이 될텐데, 왜 누적합을 할까?
# 누적합을 쓰지 않으면 생기는 문제점?
	#원래 리스트의 항목 순서를 보장할 수 없음
	#즉 누적합을 안쓰고 그냥 해버리면 항목 순서가 달라질 수 있다
#누적합의 특징:
    #누적합이 칸막이의 역할을 함
		#인덱스에서 어디에 배치될 것인지 알려주는 것
#누적합에 따라 뒤에서부터 배치하면서(오른쪽에서부터 배치하면서) 안정 정렬이 됨
#누적합이 곧 해당 숫자의 자리가 되므로

for i in range(1, len(count)):  # 누적합
    count[i] = count[i] + count[i-1]

for j in range(len(nums)-1, -1, -1):  # 뒤의 자리부터 뽑아서,
    sorted_nums[count[nums[j]]-1] = nums[j] # 5가 튀어나오면 5의 위치에 뒤부터 삽입.
    count[nums[j]] -= 1  # 위치 인덱스 하나 깎음

print(sorted_nums)
```
