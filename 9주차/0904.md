### Hash 값이 충돌하는 경우

- 어떤 해시 함수를 쓰더라도, 결과값이 동일할 가능성이 있음
- 예시) 6으로 나눈 값을 해시값으로 한다면, ‘안녕하세요’ 와 ‘반갑습니다’ 의 해시값이 동일

1. 해결법
   - **분리 연결법(separate Chaining)**
     1. 정의
        - 추가 메모리를 사용해 다음 데이터의 주소를 저장하는 것
        - 연결 리스트(Linked List)를 이용
        - 키에 매핑된 인덱스가 가리키는 연결 리스트에, 노드를 추가한 후 값을 추가함
          ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/da325db6-14df-45f2-95bb-38fea9f16132/Untitled.png)
     2. 검색/삭제 방법
        - 검색
          - 해시 함수를 통해 인덱스를 구함
          - 해당 인덱스의 연결 리스트를 선형적으로 검사
          - 해당 키의 노드가 존재하는지 확인 후 값을 출력
        - 삭제
          - 검색과 동일하게 검사 후, 해당 키의 노드를 삭제
     3. 특징
        - 해시 테이블의 확장이 필요 없고, 쉽게 삭제할 수 있음
        - 데이터의 주소 값(인덱스)이 바뀌지 않음
        - 동일한 버킷에 중복되는 데이터가 많아지면 캐시의 효율성이 감소함
   - **개방 주소법**
     1. 정의

        - 해시 충돌이 발생하면 테이블 내의 새로운 주소를 탐사
        - 비어있는 곳에 충돌된 데이터를 입력하는 방식
        - 어떤 방식으로 비어있는 곳에 데이터를 입력하는가에 따라 여러 종류가 있음

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9eb73037-5f21-45b1-98be-88b9071032fb/Untitled.png)

        1. 선형 탐색
           - 현재 버킷 index로부터 고정폭만큼 이동해 비어있으면 데이터 저장
        2. 제곱 탐색
           - 해시의 저장순서 폭을 제곱으로 저장함
           - 예) 처음 충돌시 1, 다음 충돌시 $2^2, 3^2, 4^2 ....$
        3. 이중 해시
           - 해시된 값을 한번 더 해싱함
           - 한번 더 해싱하기 때문에 많은 연산이 일어남

### Python 구현

- hash값이 충돌하는 경우를 고려하지 않음
- 유니코드로 변환된 값을 테이블의 길이만큼으로 나눈 나머지를 이용

```python
# Hash Table
class HashTable:
    def __init__(self, table_size):
        self.size = table_size
        self.hash_table = [0 for a in range(self.size)]

    def getKey(self, data):
        #ord : 하나의 문자를 인자로 받고 해당 문자에 해당하는 유니코드 정수를 반환
        self.key = ord(data[0])
        return self.key

    def hashFunction(self, key):
        #유니코드 정수로 변환한 값을 미리 입력받은 hash table size만큼으로 나눈 나머지값을 반환
        return key % self.size

    def getAddress(self, key):
        myKey = self.getKey(key)
        hash_address = self.hashFunction(myKey)
        return hash_address

    def save(self, key, value):
        hash_address = self.getAddress(key)
        self.hash_table[hash_address] = value

    def read(self, key):
        hash_address = self.getAddress(key)
        return self.hash_table[hash_address]

    def delete(self, key):
        hash_address = self.getAddress(key)

        if self.hash_table[hash_address] != 0:
            self.hash_table[hash_address] = 0
            return True
        else:
            return False

# Test Code
#table 길이를 8로 지정
h_table = HashTable(8)
#key, value 값을 입력
h_table.save('a', '1111')
h_table.save('b', '3333')
h_table.save('c', '5555')
h_table.save('d', '8888')
print(h_table.hash_table)
#[0, '1111', '3333', '5555', '8888', 0, 0, 0]
print(h_table.read('d'))
#8888
h_table.delete('d')
print(h_table.hash_table)
[0, '1111', '3333', '5555', 0, 0, 0, 0]
```

- 개방 주소법 중 선형 탐색을 통해 구현

```python
# close hashing
class CloseHash:
    def __init__(self, table_size):
        self.size = table_size
        self.hash_table = [0 for a in range(self.size)]

    def getKey(self, data):
        self.key = ord(data[0])
        return self.key

    def hashFunction(self, key):
        return key % self.size

    def getAddress(self, key):
        myKey = self.getKey(key)
        hash_address = self.hashFunction(myKey)
        return hash_address

    def save(self, key, value):
        hash_address = self.getAddress(key)
        #해당 인덱스에 이미 값이 채워져 있다면
        #처음 나타나는 빈 공간에 채움

        if self.hash_table[hash_address] != 0:
            for a in range(hash_address, len(self.hash_table)):
                if self.hash_table[a] == 0:
                    self.hash_table[a] = [key, value]
                    return
                #이미 key값이 있는 경우, 덮어씌움(재할당)
                elif self.hash_table[a][0] == key:
                    self.hash_table[a] = [key, value]
                    return
            return None
        else:
            self.hash_table[hash_address] = [key, value]

    def read(self, key):
        hash_address = self.getAddress(key)

        for a in range(hash_address, len(self.hash_table)):
            if self.hash_table[a][0] == key:
                return self.hash_table[a][1]
        return None

    def delete(self, key):
        hash_address = self.getAddress(key)

        for a in range(hash_address, len(self.hash_table)):
            if self.hash_table[a] == 0:
                continue
            if self.hash_table[a][0] == key:
                self.hash_table[a] = 0
                return
        return False

# Test Code
h_table = CloseHash(8)

data1 = 'aa'
data2 = 'ad'
print(ord(data1[0]), ord(data2[0]))
#97 97
h_table.save('aa', '3333')
h_table.save('ad', '9999')
print(h_table.hash_table)
#[0, ['aa', '3333'], ['ad', '9999'], 0, 0, 0, 0, 0]
h_table.read('ad')

h_table.delete('aa')
print(h_table.hash_table)
#[0, 0, ['ad', '9999'], 0, 0, 0, 0, 0]
h_table.delete('ad')
print(h_table.hash_table)
#[0, 0, 0, 0, 0, 0, 0, 0]
```
